[
  " Вопрос: 1. Какие типы данных присутствуют в JavaScript? Ответ: Существует 8 типов данных. 7 примитивных и 1 сложный тип данных. Примитивные типы: number, string, boolean, symbol, bigInt, null, undefined. Сложный тип - object. Он используется для коллекций данных и для объявления более сложных сущностей. Также он передается по ссылке, а простые типы данных по значению Видео: https://youtu.be/eYIVlRn4qJ4",
  " Вопрос: 2. Что такое NaN? Ответ: NaN (not a number) - это значение получаемое в результате выполнения числовой операции над нечисловым значением. Его тип данных number. NaN не равен самому себе. Провернку на NaN можно сделать с помощью Number.isNaN Видео: https://youtu.be/vAKlyQcT4j0",
  " Вопрос: 3. В чем разница между null и undefined? Ответ: undefined (неопределенный) представляет собой значение по умолчанию:\n    1 - переменной, которая обьявлена без инициализации;\n    2 - функции, которая ничего не возвращает явно;\n    3 - несуществующего свойства объекта.\nnull - это значение «отсутствия значения». Присваивается переменной явно.\n Видео: https://youtu.be/EyYUKYHMgYw",
  " Вопрос: 4. Чем отличается строгое и не строгое равенство (\u003d\u003d и \u003d\u003d\u003d)? Ответ: Строгое сравнивает значения по типу данных и значению\nНе строгое приводит значения к одному типу а потом эти значения сравнивает.  Видео: https://youtu.be/Z9JV9ge7ZwQ",
  " Вопрос: 5. Почему результатом сравнения двух похожих объектов является false? Ответ: Потому что обьекты - это ссылочные типы данных. 2 одинаковы с виду обьекта имеют разные ссылки, и по этому операция сравнения будет возвращать false. Видео: https://youtu.be/Vg4DSuFB2XA",
  " Вопрос: 6. Как проверить 2 обьекта на идентичность? Ответ: 1 - использовать JSON.stringify для приведения обьектов в строку и сравнить их уже как 2 строки. Такой подход имеет ограничения. Если в обьекте будут методы или symbol - JSON.stringify не сможет конвертировать их в строку. \n2 - написать или использовать из библиотеки функцию deepEqual которая будет проходить циклом по ключам двух обьектов и будет проверять значение этих ключей. Функция должна работать рекурсивно. Видео: https://youtu.be/r_z3MJc9PjE",
  " Вопрос: 7. Как сделать копию обьекта? Ответ: Существует понятие глубокого и поверхносного копирования. Глубокое - это копирование обьекта и все его уровней вложенности. Поверхносное - это коприрование только первого уровня вложенности, а для остального копируется ссылка.\nСпособы поверхностого копирования:\n1 - использовать spread оператор (...) \n2 - использовать Object.assign()\n\nСпособы глубокого копирования:\n1 -  использовать JSON.stringify - JSON.parse для конвертирования обьектва в строку и потом обратно. Имеет ограничения по копированию методов и symbols\n2 - написать или использовать из библиотеки функцию deepClone которая будет рекурсивно проходить по ключам обьекта и копировать их в новый обьект Видео: https://youtu.be/0oAvl2jDG-Q",
  " Вопрос: 8. Чем отличаются переменные var, let и const? Ответ: var - переменную можно инициализировать после обьявления, можно изменять, имеет функциональную область видимости, имеет hoisting. Сейчас почти не используют при написании нового кода\nlet - переменную можно инициализировать после обьявления, можно изменять, имеет блочную область видимости, не имеет hoisting\nconts - переменную обязательно нужно инициализировать во-время обьявления, нельзя изменять, имеет блочную область видимости, не имеет hoisting Видео: https://youtu.be/q1-_aRvqW0A",
  " Вопрос: 9. Как узнать является ли объект массивом? Ответ: Для этого можно использовать метод Array.isArray. Видео: https://youtu.be/IupIbytNB0I",
  " Вопрос: 10. Какие перебирающие методы массивов вы знаете? Ответ: Есть следущие методы:\n- forEach – для перебора массива.\n- filter – для фильтрации массива.\n- every/some – для проверки массива.\n- map – для трансформации массива в массив.\n- reduce/reduceRight – для прохода по массиву с вычислением значения.\n- sort - сортирует массив Видео: https://youtu.be/d9womHbuZos",
  " Вопрос: 11. Как объединить массивы? Ответ: 1 - Можно использовать метод concat()\n2 - Можно использоваться оператором spread и распылить эти массив в 1 один общий массив Видео: https://youtu.be/9lAsoieyTww",
  " Вопрос: 12. Как узнать находится ли элемент в массиве? Ответ: 1 - Использовать метод includes, который возвращает true если елемент находиться в массиве\n2 - Использовать метод indexOf который возвращает индекс найденого елемента в массиве или -1 если елемента в массиве нет Видео: https://youtu.be/JwBzTL_qKok",
  " Вопрос: 13. Что такое поднятие (hoisting) ? Ответ: Это механизм в JavaScript, в котором переменные и объявления функций, передвигаются вверх своей области видимости перед тем, как код будет выполнен. Поднимаються переменные var и function declaration Видео: https://youtu.be/Ure2dUwes1M",
  " Вопрос: 14. Каким будет значение переменной var при обращении к ней до ее обьявления? Ответ: undefined Видео: https://youtu.be/C7CzQgHLBMY",
  " Вопрос: 15. Что будет если обратится к переменной let/const  до её обьявления? Ответ: Будет ошибка типа ReferenceError. Такого индетификатора ещё не существует. Видео: https://youtu.be/imQ9ahYWn_Q",
  " Вопрос: 16. Что такое область видимости (Scope)? Ответ: Это место, где (или откуда) мы имеем доступ к переменным или функциям. JS имеем 4 типа областей видимости: глобальная, функциональная, блочная (ES6) и область видимости eval. Видео: https://youtu.be/F2ydYbKeFfo",
  " Вопрос: 17. Чем Function Declaration отличается от Function Expression? Ответ: Function Expression создаётся, когда выполнение доходит до него, и затем уже может использоваться.\nFunction Declaration можно использовать во всем скрипте (или блоке кода, если функция объявлена в блоке). Видео: https://youtu.be/gYvh5-S9wMw",
  " Вопрос: 18. Чем стрелочная функция отличается от обычной? Ответ: 1 - Стрелочная функция не имее собственного this. Она берет его по месту создания. В обычной функции this устанавливается во время вызова.\n2 - Стрелочная функция не имеет arguments. \n3 - Стрелочная функция не имеет prototype.\n4 - Стрелочная функция имее короткий синтаксис неявного возврата значения. Видео: https://youtu.be/HvZZoxQsiEU",
  " Вопрос: 19. Есть ли аналог arguments для стрелочной функции? Ответ: Можно использовать rest оператор (...) для того, чтобы собрать все аргументы с которыми вызвана функция в массив. Видео: https://youtu.be/72nzpfcpdR8",
  " Вопрос: 20. Что такое лексическое окружение (Lexical Environment)? Ответ: Это свойства внитреннего обьекта функции который создается во время ее запуска. Туда записываются аргументы, функции и переменные. Так же там находится ссылка на внешнее лексическое окружение. Видео: https://youtu.be/sAQpetM7OxM",
  " Вопрос: 21. Что является глобальным лексическим окружение? Ответ: window Видео: https://youtu.be/13EmgaTFspA",
  " Вопрос: 22. Что такое замыкание (Closures)? Ответ: Это способность функции во время создания запоминать ссылки на переменные функции и параметры, находящиеся в текущем лексическом окружении, а так же в лексическом окружении родительской функции и так до глобальной области видимости. Замыкание подразумивает именно внешние переменные, а не саму функцию. Видео: https://youtu.be/qKOrxTFwcYE",
  " Вопрос: 23. Для чего используют замыкания? Ответ: 1 - Часто для создания приватных переменных и функций (инкапсуляция).\n2 - Для сохраниения промежуточных параметров вызова функции (карррирование).\n Видео: https://youtu.be/BlgDMsvGK34",
  " Вопрос: 24. Что такое IIFE? Ответ: Immediately Invoked Function Expression - это функция, которая вызывается или выполняется сразу же после создания или объявления. Видео: https://youtu.be/nyvR0F2l2vg",
  " Вопрос: 25. Что такое this? Ответ: Это ссылка на контекст вызова функции. Контекстом является обьект который в данный момент выполняет или вызывает функцию. Для стрелочной функции - это обьект в котором она создана, а в обычной функции - которым она вызвана.\n1 - this в обьекте - указывает на сам обьект\n2 - this в классе - казывает на екземпляр класса\n3 - глобальным контекстом является window (или undefined в режиме use strict) Видео: https://youtu.be/F5UUM-lKEKM",
  " Вопрос: 26. Как можно подменить контекст вызова функции? Ответ: Есть 3 метода: call, apply, bind. \ncall и apply вызывают функцию из заданным контекстом\nbind возвращает новую функцию с уже навсегда привязанным контекстом Видео: https://youtu.be/EjdPt_CcbpM",
  " Вопрос: 27. Можно ли изменить контекст функции которую возвратил метод bind? Ответ: Нет, bind привязывает контекст навсегда. Видео: https://youtu.be/_vz2-MwNrpM",
  " Вопрос: 28. Можно ли подменить контекст вызова стрелочной функции? Ответ: Нет. Стрелочная функция не имеет методов call, apply, bind а так же своих аналогов. Так же она использует контекст в котором создана а не контекст в котором вызвана. Видео: https://youtu.be/LL-3brtJq-M",
  " Вопрос: 29. Что такое прототип обьекта? Ответ: Другой объект, с которым связан текущий объект. Он используется как запасной вариант для свойств и методов, не существующих в текущем объекте. Это также один из способов обмена свойствами и функциональностью между объектами. Это основная концепция прототипного наследования в JS. Видео: https://youtu.be/AKp_dg3eiUY",
  " Вопрос: 30. Как работает прототипное наследнование в JS? Ответ: Когда мы хотим прочитать свойство из обьекта, а оно отсутсвует - JS попытается его прочиться из прототипа обьекта. Если свойства нет в прототипе, JS попытается его прочиться из прототипа прототипа, и т.д. до тех пор, пока свойство не будет найдено или цепочка прототипов не закончится. В таком случае JS возвратит undefined. Видео: https://youtu.be/UTvCc8w9sbk",
  " Вопрос: 31. Как создать обьект в котором не будет прототипа? Ответ: Использовать Object.create(). Данный метод принимает первым аргументом обьект, который будет являться прототипом обьекта, который он возвратит. Если мы вызовем Object.create() из аргументом null, будет создан обьект без прототипа Видео: https://youtu.be/B0kIGBJSBpw",
  " Вопрос: 32. Как проверить является ли свойство обьекта личным совйством или это свойтво прототипа? Ответ: Можно использовать метод hasOwnProperty который возвращает массив только личных свойств. Если свойство находится в этой коллекции - это личное свойство обьекта. Видео: https://youtu.be/CJ0imxCvJKk",
  " Вопрос: 33. Как запретить изменять обьект? Ответ: Есть метод Object.freeze(), который \"замораживает\" обьект от изменений. Данный метод работает только в одну сторону. Отменить действие данного метода уже невозможно.\nEсть метод Object.seal(), который запрещает изменять уже существующие свойства, но новый свойства добавлять можно.\nТак же есть метод Object.preventExtensions(), который запрещает добавлять новые свойства в обьект. Видео: https://youtu.be/qfZCe0iAo4Y",
  " Вопрос: 34. Что такое дескрипторы свойств обьекта? Ответ: Дескриптор - это обьект конфигурации свойства в обьекте. Он имеет 4 свойства:\nvalue - значение свойства обьекта.\nwritable - указывает можно ли изменять значаение данного свойства\nenumerable - указывает будет ли видно свтойство во время перебора свойств обьекта\nconfigurable - указывает можно ли добавлять или удалять свойства обьекта, а так же можно ли изметять дескрипторы его свойств Видео: https://youtu.be/DKqFt4B7mbA",
  " Вопрос: 35. Чем отличается функция конструктор и класс? Ответ: Класс - это синтаксический сахар над функцией конструктором. При создании экземпляра класса, методы описанные в нем попадают в прототип, а методы описанные внутри функции конструктора попадут в сам экземпляр. Для того, чтобы методы описанные внутри функции конструктора попали в прототип их нужно отдельно туда добавить.   Видео: https://youtu.be/KoGEra69o4w",
  " Вопрос: 36. Что нужно сделать, чтобы метод класса попал в его экземпляр? Ответ: Такой метод нужно описать внутри конструктора Видео: https://youtu.be/ZilvNqv5Khg",
  " Вопрос: 37. Присутствует ли в JS множественное наследование? Ответ: Нет. Так как наследование в JS базируется на прототипах, у одного обьекта может быть только 1 прототип. Видео: https://youtu.be/cUELDUHKYo4",
  " Вопрос: 38. Что такое Promise? Ответ: Это обьект который используется для отложенных и асинхронных вычислений. Promise имеет 3 состояния:\n- ожидание (pending): начальное состояние, не исполнен и не отклонён.\n- исполнено (fulfilled): операция завершена успешно.\n- отклонено (rejected): операция завершена с ошибкой.\n Видео: https://youtu.be/nJmnJKzUMfU",
  " Вопрос: 39. Для чего нужен метод Promise.all? Ответ: Ожидает исполнения всех промисов или отклонения любого из них.\nВозвращает промис, который исполнится после исполнения всех промисов. В случае, если любой из промисов будет отклонён, Promise.all будет также отклонён.\nУ него есть аналог Promise.allSetled, который исполняется как-только все полученные промисы завершены (исполнены или отклонены), содержащий массив результатов исполнения полученных промисов. Видео: https://youtu.be/lPzNPvyIiUk",
  " Вопрос: 40. Для чего нужен метод Promise.race? Ответ: Ожидает исполнения или отклонения любого из полученных промисов. Возвращает промис, который будет исполнен или отклонён с результатом исполнения первого исполненного или отклонённого промиса. Видео: https://youtu.be/ZcbEfKHZ_Dg",
  " Вопрос: 41. Для чего нужен синтаксис async/await? Ответ: Ключевое слово async делает созданную функцию асинхронной. \nАсинхронная функция может содержать ключевое слово await, которое приостанавливает выполнение асинхронной функции и ожидает ответа от переданного Promise, затем возобновляя выполнение функции async и возвращая полученное значение. Видео: https://youtu.be/tZAtBMqhSoE",
  " Вопрос: 42. Как обрабатывать ошибки в async/await функции? Ответ: Для этого можно использовать конструкцию try...catch() Видео: https://youtu.be/PFemxa5cSUs",
  " Вопрос: 43. Что такое event loop? Ответ: Это механизм, который отвечает за выполнение кода, сбора и обработки событий и выполнения под-задач из очереди. В концепции event loop есть несколько блоков:\n- call stack - отвечает за создаёт контекст выполнения функции. Каждая вызываемая функция попадает в call stack.\n- heap - это большая неструктурированная области памяти, в которой хранятся обьявленные переменные, функции, и т.д.\n- third party API - API, которые предоставляет окружение. К примеру, метод fecth, который предоставляется браузером.\n- queue - список задач, подлежащих обработке. Каждая задача ассоциируется с некоторой функцией, которая будет вызвана, чтобы обработать эту задачу. Видео: https://youtu.be/V5Dj4M_V1ig"
]