[
  [
    "1. Какие типы данных присутствуют в JavaScript?",
    "Существует 8 типов данных. 7 примитивных и 1 сложный тип данных. Примитивные типы: number, string, boolean, symbol, bigInt, null, undefined. Сложный тип - object. Он используется для коллекций данных и для объявления более сложных сущностей. Также он передается по ссылке, а простые типы данных по значению",
    "https://youtu.be/eYIVlRn4qJ4"
  ],
  [],
  [
    "2. Что такое NaN?",
    "NaN (not a number) - это значение получаемое в результате выполнения числовой операции над нечисловым значением. Его тип данных number. NaN не равен самому себе. Провернку на NaN можно сделать с помощью Number.isNaN",
    "https://youtu.be/vAKlyQcT4j0"
  ],
  [],
  [
    "3. В чем разница между null и undefined?",
    "undefined (неопределенный) представляет собой значение по умолчанию:\n    1 - переменной, которая обьявлена без инициализации;\n    2 - функции, которая ничего не возвращает явно;\n    3 - несуществующего свойства объекта.\nnull - это значение «отсутствия значения». Присваивается переменной явно.\n",
    "https://youtu.be/EyYUKYHMgYw"
  ],
  [],
  [
    "4. Чем отличается строгое и не строгое равенство (\u003d\u003d и \u003d\u003d\u003d)?",
    "Строгое сравнивает значения по типу данных и значению\nНе строгое приводит значения к одному типу а потом эти значения сравнивает. ",
    "https://youtu.be/Z9JV9ge7ZwQ"
  ],
  [],
  [
    "5. Почему результатом сравнения двух похожих объектов является false?",
    "Потому что обьекты - это ссылочные типы данных. 2 одинаковы с виду обьекта имеют разные ссылки, и по этому операция сравнения будет возвращать false.",
    "https://youtu.be/Vg4DSuFB2XA"
  ],
  [],
  [
    "6. Как проверить 2 обьекта на идентичность?",
    "1 - использовать JSON.stringify для приведения обьектов в строку и сравнить их уже как 2 строки. Такой подход имеет ограничения. Если в обьекте будут методы или symbol - JSON.stringify не сможет конвертировать их в строку. \n2 - написать или использовать из библиотеки функцию deepEqual которая будет проходить циклом по ключам двух обьектов и будет проверять значение этих ключей. Функция должна работать рекурсивно.",
    "https://youtu.be/r_z3MJc9PjE"
  ],
  [],
  [
    "7. Как сделать копию обьекта?",
    "Существует понятие глубокого и поверхносного копирования. Глубокое - это копирование обьекта и все его уровней вложенности. Поверхносное - это коприрование только первого уровня вложенности, а для остального копируется ссылка.\nСпособы поверхностого копирования:\n1 - использовать spread оператор (...) \n2 - использовать Object.assign()\n\nСпособы глубокого копирования:\n1 -  использовать JSON.stringify - JSON.parse для конвертирования обьектва в строку и потом обратно. Имеет ограничения по копированию методов и symbols\n2 - написать или использовать из библиотеки функцию deepClone которая будет рекурсивно проходить по ключам обьекта и копировать их в новый обьект",
    "https://youtu.be/0oAvl2jDG-Q"
  ],
  [],
  [
    "8. Чем отличаются переменные var, let и const?",
    "var - переменную можно инициализировать после обьявления, можно изменять, имеет функциональную область видимости, имеет hoisting. Сейчас почти не используют при написании нового кода\nlet - переменную можно инициализировать после обьявления, можно изменять, имеет блочную область видимости, не имеет hoisting\nconts - переменную обязательно нужно инициализировать во-время обьявления, нельзя изменять, имеет блочную область видимости, не имеет hoisting",
    "https://youtu.be/q1-_aRvqW0A"
  ],
  [],
  [
    "9. Как узнать является ли объект массивом?",
    "Для этого можно использовать метод Array.isArray.",
    "https://youtu.be/IupIbytNB0I"
  ],
  [],
  [
    "10. Какие перебирающие методы массивов вы знаете?",
    "Есть следущие методы:\n- forEach – для перебора массива.\n- filter – для фильтрации массива.\n- every/some – для проверки массива.\n- map – для трансформации массива в массив.\n- reduce/reduceRight – для прохода по массиву с вычислением значения.\n- sort - сортирует массив",
    "https://youtu.be/d9womHbuZos"
  ],
  [],
  [
    "11. Как объединить массивы?",
    "1 - Можно использовать метод concat()\n2 - Можно использоваться оператором spread и распылить эти массив в 1 один общий массив",
    "https://youtu.be/9lAsoieyTww"
  ],
  [],
  [
    "12. Как узнать находится ли элемент в массиве?",
    "1 - Использовать метод includes, который возвращает true если елемент находиться в массиве\n2 - Использовать метод indexOf который возвращает индекс найденого елемента в массиве или -1 если елемента в массиве нет",
    "https://youtu.be/JwBzTL_qKok"
  ],
  [],
  [
    "13. Что такое поднятие (hoisting) ?",
    "Это механизм в JavaScript, в котором переменные и объявления функций, передвигаются вверх своей области видимости перед тем, как код будет выполнен. Поднимаються переменные var и function declaration",
    "https://youtu.be/Ure2dUwes1M"
  ],
  [],
  [
    "14. Каким будет значение переменной var при обращении к ней до ее обьявления?",
    "undefined",
    "https://youtu.be/C7CzQgHLBMY"
  ],
  [],
  [
    "15. Что будет если обратится к переменной let/const  до её обьявления?",
    "Будет ошибка типа ReferenceError. Такого индетификатора ещё не существует.",
    "https://youtu.be/imQ9ahYWn_Q"
  ],
  [],
  [
    "16. Что такое область видимости (Scope)?",
    "Это место, где (или откуда) мы имеем доступ к переменным или функциям. JS имеем 4 типа областей видимости: глобальная, функциональная, блочная (ES6) и область видимости eval.",
    "https://youtu.be/F2ydYbKeFfo"
  ],
  [],
  [
    "17. Чем Function Declaration отличается от Function Expression?",
    "Function Expression создаётся, когда выполнение доходит до него, и затем уже может использоваться.\nFunction Declaration можно использовать во всем скрипте (или блоке кода, если функция объявлена в блоке).",
    "https://youtu.be/gYvh5-S9wMw"
  ],
  [],
  [
    "18. Чем стрелочная функция отличается от обычной?",
    "1 - Стрелочная функция не имее собственного this. Она берет его по месту создания. В обычной функции this устанавливается во время вызова.\n2 - Стрелочная функция не имеет arguments. \n3 - Стрелочная функция не имеет prototype.\n4 - Стрелочная функция имее короткий синтаксис неявного возврата значения.",
    "https://youtu.be/HvZZoxQsiEU"
  ],
  [],
  [
    "19. Есть ли аналог arguments для стрелочной функции?",
    "Можно использовать rest оператор (...) для того, чтобы собрать все аргументы с которыми вызвана функция в массив.",
    "https://youtu.be/72nzpfcpdR8"
  ],
  [],
  [
    "20. Что такое лексическое окружение (Lexical Environment)?",
    "Это свойства внитреннего обьекта функции который создается во время ее запуска. Туда записываются аргументы, функции и переменные. Так же там находится ссылка на внешнее лексическое окружение.",
    "https://youtu.be/sAQpetM7OxM"
  ],
  [],
  [
    "21. Что является глобальным лексическим окружение?",
    "window",
    "https://youtu.be/13EmgaTFspA"
  ],
  [],
  [
    "22. Что такое замыкание (Closures)?",
    "Это способность функции во время создания запоминать ссылки на переменные функции и параметры, находящиеся в текущем лексическом окружении, а так же в лексическом окружении родительской функции и так до глобальной области видимости. Замыкание подразумивает именно внешние переменные, а не саму функцию.",
    "https://youtu.be/qKOrxTFwcYE"
  ],
  [],
  [
    "23. Для чего используют замыкания?",
    "1 - Часто для создания приватных переменных и функций (инкапсуляция).\n2 - Для сохраниения промежуточных параметров вызова функции (карррирование).\n",
    "https://youtu.be/BlgDMsvGK34"
  ],
  [],
  [
    "24. Что такое IIFE?",
    "Immediately Invoked Function Expression - это функция, которая вызывается или выполняется сразу же после создания или объявления.",
    "https://youtu.be/nyvR0F2l2vg"
  ],
  [],
  [
    "25. Что такое this?",
    "Это ссылка на контекст вызова функции. Контекстом является обьект который в данный момент выполняет или вызывает функцию. Для стрелочной функции - это обьект в котором она создана, а в обычной функции - которым она вызвана.\n1 - this в обьекте - указывает на сам обьект\n2 - this в классе - казывает на екземпляр класса\n3 - глобальным контекстом является window (или undefined в режиме use strict)",
    "https://youtu.be/F5UUM-lKEKM"
  ],
  [],
  [
    "26. Как можно подменить контекст вызова функции?",
    "Есть 3 метода: call, apply, bind. \ncall и apply вызывают функцию из заданным контекстом\nbind возвращает новую функцию с уже навсегда привязанным контекстом",
    "https://youtu.be/EjdPt_CcbpM"
  ],
  [],
  [
    "27. Можно ли изменить контекст функции которую возвратил метод bind?",
    "Нет, bind привязывает контекст навсегда.",
    "https://youtu.be/_vz2-MwNrpM"
  ],
  [],
  [
    "28. Можно ли подменить контекст вызова стрелочной функции?",
    "Нет. Стрелочная функция не имеет методов call, apply, bind а так же своих аналогов. Так же она использует контекст в котором создана а не контекст в котором вызвана.",
    "https://youtu.be/LL-3brtJq-M"
  ],
  [],
  [
    "29. Что такое прототип обьекта?",
    "Другой объект, с которым связан текущий объект. Он используется как запасной вариант для свойств и методов, не существующих в текущем объекте. Это также один из способов обмена свойствами и функциональностью между объектами. Это основная концепция прототипного наследования в JS.",
    "https://youtu.be/AKp_dg3eiUY"
  ],
  [],
  [
    "30. Как работает прототипное наследнование в JS?",
    "Когда мы хотим прочитать свойство из обьекта, а оно отсутсвует - JS попытается его прочиться из прототипа обьекта. Если свойства нет в прототипе, JS попытается его прочиться из прототипа прототипа, и т.д. до тех пор, пока свойство не будет найдено или цепочка прототипов не закончится. В таком случае JS возвратит undefined.",
    "https://youtu.be/UTvCc8w9sbk"
  ],
  [],
  [
    "31. Как создать обьект в котором не будет прототипа?",
    "Использовать Object.create(). Данный метод принимает первым аргументом обьект, который будет являться прототипом обьекта, который он возвратит. Если мы вызовем Object.create() из аргументом null, будет создан обьект без прототипа",
    "https://youtu.be/B0kIGBJSBpw"
  ],
  [],
  [
    "32. Как проверить является ли свойство обьекта личным совйством или это свойтво прототипа?",
    "Можно использовать метод hasOwnProperty который возвращает массив только личных свойств. Если свойство находится в этой коллекции - это личное свойство обьекта.",
    "https://youtu.be/CJ0imxCvJKk"
  ],
  [],
  [
    "33. Как запретить изменять обьект?",
    "Есть метод Object.freeze(), который \"замораживает\" обьект от изменений. Данный метод работает только в одну сторону. Отменить действие данного метода уже невозможно.\nEсть метод Object.seal(), который запрещает изменять уже существующие свойства, но новый свойства добавлять можно.\nТак же есть метод Object.preventExtensions(), который запрещает добавлять новые свойства в обьект.",
    "https://youtu.be/qfZCe0iAo4Y"
  ],
  [],
  [
    "34. Что такое дескрипторы свойств обьекта?",
    "Дескриптор - это обьект конфигурации свойства в обьекте. Он имеет 4 свойства:\nvalue - значение свойства обьекта.\nwritable - указывает можно ли изменять значаение данного свойства\nenumerable - указывает будет ли видно свтойство во время перебора свойств обьекта\nconfigurable - указывает можно ли добавлять или удалять свойства обьекта, а так же можно ли изметять дескрипторы его свойств",
    "https://youtu.be/DKqFt4B7mbA"
  ],
  [],
  [
    "35. Чем отличается функция конструктор и класс?",
    "Класс - это синтаксический сахар над функцией конструктором. При создании экземпляра класса, методы описанные в нем попадают в прототип, а методы описанные внутри функции конструктора попадут в сам экземпляр. Для того, чтобы методы описанные внутри функции конструктора попали в прототип их нужно отдельно туда добавить.  ",
    "https://youtu.be/KoGEra69o4w"
  ],
  [],
  [
    "36. Что нужно сделать, чтобы метод класса попал в его экземпляр?",
    "Такой метод нужно описать внутри конструктора",
    "https://youtu.be/ZilvNqv5Khg"
  ],
  [],
  [
    "37. Присутствует ли в JS множественное наследование?",
    "Нет. Так как наследование в JS базируется на прототипах, у одного обьекта может быть только 1 прототип.",
    "https://youtu.be/cUELDUHKYo4"
  ],
  [],
  [
    "38. Что такое Promise?",
    "Это обьект который используется для отложенных и асинхронных вычислений. Promise имеет 3 состояния:\n- ожидание (pending): начальное состояние, не исполнен и не отклонён.\n- исполнено (fulfilled): операция завершена успешно.\n- отклонено (rejected): операция завершена с ошибкой.\n",
    "https://youtu.be/nJmnJKzUMfU"
  ],
  [],
  [
    "39. Для чего нужен метод Promise.all?",
    "Ожидает исполнения всех промисов или отклонения любого из них.\nВозвращает промис, который исполнится после исполнения всех промисов. В случае, если любой из промисов будет отклонён, Promise.all будет также отклонён.\nУ него есть аналог Promise.allSetled, который исполняется как-только все полученные промисы завершены (исполнены или отклонены), содержащий массив результатов исполнения полученных промисов.",
    "https://youtu.be/lPzNPvyIiUk"
  ],
  [],
  [
    "40. Для чего нужен метод Promise.race?",
    "Ожидает исполнения или отклонения любого из полученных промисов. Возвращает промис, который будет исполнен или отклонён с результатом исполнения первого исполненного или отклонённого промиса.",
    "https://youtu.be/ZcbEfKHZ_Dg"
  ],
  [],
  [
    "41. Для чего нужен синтаксис async/await?",
    "Ключевое слово async делает созданную функцию асинхронной. \nАсинхронная функция может содержать ключевое слово await, которое приостанавливает выполнение асинхронной функции и ожидает ответа от переданного Promise, затем возобновляя выполнение функции async и возвращая полученное значение.",
    "https://youtu.be/tZAtBMqhSoE"
  ],
  [],
  [
    "42. Как обрабатывать ошибки в async/await функции?",
    "Для этого можно использовать конструкцию try...catch()",
    "https://youtu.be/PFemxa5cSUs"
  ],
  [],
  [
    "43. Что такое event loop?",
    "Это механизм, который отвечает за выполнение кода, сбора и обработки событий и выполнения под-задач из очереди. В концепции event loop есть несколько блоков:\n- call stack - отвечает за создаёт контекст выполнения функции. Каждая вызываемая функция попадает в call stack.\n- heap - это большая неструктурированная области памяти, в которой хранятся обьявленные переменные, функции, и т.д.\n- third party API - API, которые предоставляет окружение. К примеру, метод fecth, который предоставляется браузером.\n- queue - список задач, подлежащих обработке. Каждая задача ассоциируется с некоторой функцией, которая будет вызвана, чтобы обработать эту задачу.",
    "https://youtu.be/V5Dj4M_V1ig"
  ]
]